# Required: HACS integration (https://hacs.xyz/)
# Required: config-template-card (https://github.com/iantrich/config-template-card)
# Required: apexcharts-card (https://github.com/RomRider/apexcharts-card)
# Required: solcast integration (https://www.home-assistant.io/integrations/solcast/) with sensors:
#   sensor.solcast_pv_forecast_forecast_today, sensor.solcast_pv_forecast_forecast_tomorrow,
#   sensor.solcast_pv_forecast_forecast_day_3, sensor.solcast_pv_forecast_forecast_day_4,
#   sensor.solcast_pv_forecast_forecast_day_5, sensor.solcast_pv_forecast_forecast_day_6,
#   sensor.solcast_pv_forecast_forecast_day_7
# Optional: Edit refund amount to match your country/state/nation/energy-provider, line 46 and line 155

type: vertical-stack
cards:
  - type: conditional
    conditions:
      - condition: state
        entity: sensor.energi_data_service
        state: unavailable
    card:
      type: horizontal-stack
      cards:
        - type: markdown
          content: "# Energi Data Service er nede <font color=red>!!!</font>"
        - show_name: true
          show_icon: true
          type: button
          entity: sensor.energi_data_service
          tap_action:
            action: call-service
            service: homeassistant.reload_config_entry
            target:
              entity_id: sensor.energi_data_service
          hold_action:
            action: none
          icon: mdi:reload
          name: Genstart Energi Data Service
          show_state: true
  - type: conditional
    conditions:
      - condition: state
        entity: sensor.energi_data_service
        state_not: unavailable
    card:
      type: custom:config-template-card
      variables:
        refund: 0.0
        today_prices: |
          states['sensor.energi_data_service'].attributes.today || []
        tomorrow_prices: |
          states['sensor.energi_data_service'].attributes.tomorrow || []
        forecast_prices: |
          if (states['sensor.energi_data_service'].attributes.forecast) {
            states['sensor.energi_data_service'].attributes.forecast.map(item =>
            item.price)
          } else { []}
        total_hours: >
          const allPrices = [...vars.today_prices, ...vars.tomorrow_prices,
          ...vars.forecast_prices]; allPrices.length
        lowest_price: >-
          let min = 999; const allPrices = [...vars.today_prices,
          ...vars.tomorrow_prices, ...vars.forecast_prices];
          allPrices.forEach(price => {
            if (price - vars.refund < min) min = price - vars.refund;
          }); min * 1.05
        highest_price: >-
          let max = -999; const allPrices = [...vars.today_prices,
          ...vars.tomorrow_prices, ...vars.forecast_prices];
          allPrices.forEach(price => {
            if (price - vars.refund > max) max = price - vars.refund;
          }); max * 0.95
        mean_price: >-
          let sum = 0.0; const allPrices = [...vars.today_prices,
          ...vars.tomorrow_prices, ...vars.forecast_prices];
          allPrices.forEach(price => {
            sum += price - vars.refund;
        step_under_mean: |
          (vars.mean_price - vars.lowest_price) / 5
        step_over_mean: |
          (vars.highest_price - vars.mean_price) / 5
        price1: vars.lowest_price
        price2: vars.mean_price - vars.step_under_mean * 4
        price3: vars.mean_price - vars.step_under_mean * 3
        price4: vars.mean_price - vars.step_under_mean * 2
        price5: vars.mean_price - vars.step_under_mean * 1
        price6: vars.mean_price
        price7: vars.mean_price + vars.step_over_mean * 1
        price8: vars.mean_price + vars.step_over_mean * 2
        price9: vars.mean_price + vars.step_over_mean * 3
        price10: vars.mean_price + vars.step_over_mean * 4
        price11: vars.highest_price
        total_span: 24 * 7
      entities: []
      card:
        type: custom:apexcharts-card
        apex_config:
          chart:
            height: 300px
          xaxis:
            tooltip:
              enabled: false
          tooltip:
            shared: true
            intersect: false
            fixed:
              enabled: true
              position: topLeft
            x:
              show: true
        all_series_config:
          unit: kWh
          extend_to: false
          fill_raw: zero
          show:
            legend_value: false
            offset_in_name: false
        experimental:
          color_threshold: true
          brush: true
        brush:
          selection_span: ${total_span + "h"}
        header:
          title: >-
            ${"Elpriser pr. time (kr/kWh) ðŸ”µ" + vars.lowest_price.toFixed(2) + "
            ðŸŸ¢" + vars.mean_price.toFixed(2) + " ðŸŸ£" +
            vars.highest_price.toFixed(2)}
          show: true
          standard_format: false
          show_states: false
          colorize_states: true
        now:
          show: true
          label: Nu
        graph_span: ${total_span +"h"}
        span:
          start: day
        yaxis:
          - id: price
            min: 0
          - id: solar
            opposite: true
            decimals: 1
            max: ~6.0
            min: 0
        show:
          loading: true
          last_updated: true
        series:
          - entity: sensor.energi_data_service
            yaxis_id: price
            type: column
            name: Inkl. afgifter
            unit: kr.
            color: green
            data_generator: |
              var refund = 0.0;
              var data = entity.attributes.raw_today.map((start, index) => {
                return [new Date(start["hour"]), entity.attributes.raw_today[index]["price"] - refund];
              });
              if (entity.attributes.forecast) {
                var forecast = entity.attributes.forecast.map((start, index) => {
                  return [new Date(start["hour"]), entity.attributes.forecast[index]["price"] - refund];
                });
                data = data.concat(forecast);
              }
              if (entity.attributes.tomorrow_valid) {
                var tomorrow = entity.attributes.raw_tomorrow.map((start, index) => {
                  return [new Date(start["hour"]), entity.attributes.raw_tomorrow[index]["price"] - refund];
                });
                data = data.concat(tomorrow);
              }
              //console.log('energi_data_service ', data);
              return data;
            float_precision: 2
            group_by:
              func: avg
              duration: 60min
            color_threshold:
              - value: ${vars.price1}
                color: "#0064FF"
              - value: ${vars.price2}
                color: "#0096FF"
              - value: ${vars.price3}
                color: "#00B496"
              - value: ${vars.price4}
                color: "#00FA50"
              - value: ${vars.price5}
                color: "#00FF32"
              - value: ${vars.price6}
                color: "#00FF00"
              - value: ${vars.price7}
                color: "#FFFF00"
              - value: ${vars.price8}
                color: "#FFA500"
              - value: ${vars.price9}
                color: "#FF5000"
              - value: ${vars.price10}
                color: "#C81919"
              - value: ${vars.price11}
                color: "#C800C8"
            opacity: 0.75
            show:
              in_brush: true
          - entity: sensor.solcast_pv_forecast_forecast_today
            yaxis_id: solar
            type: area
            name: Solcelle prognose
            data_generator: >
              const toUTC00 = (d) => {
                const x = new Date(d);
                return new Date(Date.UTC(
                  x.getUTCFullYear(), x.getUTCMonth(), x.getUTCDate(), x.getUTCHours(), 0, 0, 0
                ));
              };

              const map = new Map(); const eds =
              hass.states['sensor.energi_data_service']?.attributes || {}; const
              pushZero = (rows) => {
                (rows || []).forEach(r => {
                  const key = toUTC00(r.hour).getTime();
                  if (!map.has(key)) map.set(key, 0);
                });
              };

              pushZero(eds.raw_today); pushZero(eds.forecast);

              if (eds.tomorrow_valid) pushZero(eds.raw_tomorrow);

              const overlay = (series) => {
                (series || []).forEach(row => {
                  const key = toUTC00(row.period_start).getTime();
                  map.set(key, row.pv_estimate);
                });
              };


              overlay(entity.attributes.detailedHourly || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_tomorrow']?.attributes?.detailedHourly
              || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_day_3']?.attributes?.detailedHourly
              || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_day_4']?.attributes?.detailedHourly
              || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_day_5']?.attributes?.detailedHourly
              || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_day_6']?.attributes?.detailedHourly
              || []);
              overlay(hass.states['sensor.solcast_pv_forecast_forecast_day_7']?.attributes?.detailedHourly
              || []);

              const out = Array.from(map.entries())
                .sort((a,b) => a[0] - b[0])
                .map(([k,v]) => [new Date(Number(k)), v]);

              //console.log('solcast ', out);

              return out;
            color: orange
            stroke_width: 0
            opacity: 0.5
            group_by:
              func: avg
              duration: 60min
            show:
              in_brush: true
grid_options:
  columns: 60
  rows: auto
